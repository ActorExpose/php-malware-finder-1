package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/hillu/go-yara"
	"github.com/jessevdk/go-flags"
)

const RulesURI = "https://raw.githubusercontent.com/nbs-system/php-malware-finder/master/php-malware-finder/"
const DefaultDir = "/etc/phpmalwarefinder"
const ScanMaxDuration = time.Duration(60)
const TooShort = "TooShort"
const TooShortMaxLines = 2
const TooShortMinChars = 300
const DangerousMatchWeight = 2
const DangerousMinScore = 3
const FileBufferSize = 32 * 1024 // 32KB
const YaraMaxThreads = 32

var args struct { // command-line arguments specs using github.com/jessevdk/go-flags
	RulesDir      string   `short:"r" long:"rules-dir" description:"Rules location (default: /etc/phpmalwarefinder or .)"`
	ShowAll       bool     `short:"a" long:"show-all" description:"Display all matched rules"`
	Fast          bool     `short:"f" long:"fast" description:"Enable YARA's fast mode'"`
	RateLimit     int      `short:"R" long:"rate-limit" description:"Max. filesystem ops per second, 0 for no limit" default:"0"`
	Verbose       bool     `short:"v" long:"verbose" description:"Verbose mode"`
	Language      string   `short:"l" long:"lang" description:"Set language" choice:"php" choice:"asp"`
	Workers       int      `short:"w" long:"workers" description:"Number of workers to spawn for scanning" default:"32"`
	LongLines     bool     `short:"L" long:"long-lines" description:"Check long lines"`
	ExcludeCommon bool     `short:"c" long:"exclude-common" description:"Do not scan files with common extensions"`
	ExcludeImgs   bool     `short:"i" long:"exclude-imgs" description:"Do not scan image files"`
	ExcludedExts  []string `short:"x" long:"exclude-ext" description:"Additional file extensions to exclude"`
	Update        bool     `short:"u" long:"update" description:"Update rules"`
	Positional    struct {
		Target string
	} `positional-args:"yes"`
}
var scanFlags yara.ScanFlags
var stoppedWorkers int
var lineFeed = []byte{'\n'}
var dangerousMatches = map[string]struct{}{
	"PasswordProtection": {},
	"Websites":           {},
	"TooShort":           {},
	"NonPrintableChars":  {},
}
var excludedDirs = [...]string{
	"/.git/", "/.hg/", "/.svn/", "/.CVS/",
}
var excludedExts = map[string]struct{}{}
var commonExts = [...]string{
	".js", ".coffee", ".map", ".min", ".css", ".less", // static files
	".zip", ".rar", ".7z", ".gz", ".bz2", ".xz", ".tar", ".tgz", // archives
	".txt", ".csv", ".json", ".rst", ".md", ".yaml", ".yml", // plain text
	".so", ".dll", ".bin", ".exe", ".bundle", // binaries
}
var imageExts = [...]string{
	".png", ".jpg", ".jpeg", ".gif", ".svg", ".bmp", ".ico",
}
var scannedFilesCount int

// HandleError is a generic error handler which displays the error message to the user and exits if required.
func HandleError(err error, exit bool) {
	if err != nil {
		fmt.Println("ERROR:", err.Error())
		if exit {
			os.Exit(1)
		}
	}
}

// UpdateRules downloads latest YARA rules from phpmalwarefinder GitHub repository.
// Download location is either `args.RulesDir`, `/etc/phpmalwarefinder`, or the current directory.
func UpdateRules() {
	if args.Verbose {
		fmt.Println("DEBUG: updating ruleset")
	}

	downloadFile := func(uri string) []byte {
		resp, err := http.Get(uri)
		HandleError(err, true)
		defer resp.Body.Close()
		data, err := ioutil.ReadAll(resp.Body)
		HandleError(err, true)
		return data
	}
	writeFile := func(dst string, data []byte) {
		err := ioutil.WriteFile(dst, data, 0444)
		HandleError(err, true)
	}

	rulesFiles := [...]string{
		"asp.yar", "common.yar", "php.yar",
		"whitelist.yar", "whitelists/drupal.yar", "whitelists/magento2.yar",
		"whitelists/phpmyadmin.yar", "whitelists/prestashop.yar",
		"whitelists/symfony.yar", "whitelists/wordpress.yar"}

	// check if rules exist in args.RulesDir, /etc/phpmalwarefinder, or the current directory
	if _, err := os.Stat(args.RulesDir); os.IsNotExist(err) {
		cwd, _ := os.Getwd()
		commonPath := path.Join(cwd, "common.yar")
		if _, err := os.Stat(commonPath); os.IsNotExist(err) {
			fmt.Printf("ERROR: no rules in %s or ./, exiting\n", args.RulesDir)
			os.Exit(1)
		}
	}

	// download rules
	for _, rule := range rulesFiles {
		rulesUri := RulesURI + rule
		data := downloadFile(rulesUri)
		outPath := path.Join(args.RulesDir, rule)
		writeFile(outPath, data)
		fmt.Printf("updated %s\n", rule)
	}
}

// DetermineFormat tries to guess the language used in the `target` file or directory.
// When `target` is a directory, it recursively searches for the first file name not
// starting with `.` and assumes its extension is the one to use as the target language.
func DetermineFormat(target string) string {
	if f, err := os.Stat(target); os.IsNotExist(err) {
		fmt.Println("ERROR: invalid target")
		os.Exit(1)
	} else {
		if f.IsDir() {
			files, _ := ioutil.ReadDir(target)
			if files[0].IsDir() {
				return DetermineFormat(path.Join(target, files[0].Name()))
			}
			for _, f := range files {
				if f.Name()[0] != '.' {
					return filepath.Ext(files[0].Name())[1:]
				}
			}
		} else {
			return filepath.Ext(target)[1:]
		}
	}
	return ""
}

// FileStats takes a file path as argument and returns its lines and characters count.
// File reading is done using a 32KB buffer to minimize memory usage.
func FileStats(filepath string) (int, int, error) {
	f, err := os.Open(filepath)
	HandleError(err, true)
	defer f.Close()
	charCount, lineCount := 0, 0
	buf := make([]byte, FileBufferSize)
	for {
		chunkSize, err := f.Read(buf)
		charCount += chunkSize
		lineCount += bytes.Count(buf[:chunkSize], lineFeed)
		switch {
		case err == io.EOF:
			return charCount, lineCount, nil
		case err != nil:
			return charCount, lineCount, err
		}
	}
}

// ProcessFiles reads file paths from the `targets` channel, scans it, and writes matches to the `results` channel.
// Scanning is done using YARA `rules`, and using `FileStats` if `args.LongLines` is set.
// `ticker` is a `time.Time` object created with `time.Tick` used to throttle file scans to minimize impact on I/O.
func ProcessFiles(rules *yara.Rules, targets <-chan string, results chan<- map[string][]string, ticker <-chan time.Time) {
	for target := range targets {
		<-ticker
		scannedFilesCount++
		result := map[string][]string{target: {}}

		if args.LongLines {
			charCount, lineCount, err := FileStats(target)
			HandleError(err, false)
			if lineCount <= TooShortMaxLines && charCount >= TooShortMinChars {
				result[target] = append(result[target], TooShort)
			}
		}

		matches, err := rules.ScanFile(target, scanFlags, ScanMaxDuration)
		if err != nil {
			fmt.Println("ERROR:", err.Error())
			continue
		}
		for _, match := range matches {
			result[target] = append(result[target], match.Rule)
		}
		results <- result
	}
	stoppedWorkers++
	if stoppedWorkers == args.Workers {
		close(results)
	}
}

// ScanDir recursively crawls `dirName`, and writes file paths to the `targets` channel.
// Files sent to `targets` are filtered according to their extensions.
func ScanDir(dirName string, targets chan<- string, ticker <-chan time.Time) {
	visit := func(pathName string, fileInfo os.FileInfo, err error) error {
		<-ticker
		if !fileInfo.IsDir() {
			for _, dir := range excludedDirs {
				if strings.Contains(pathName, dir) {
					return nil
				}
			}
			fileExt := filepath.Ext(fileInfo.Name())
			if _, exists := excludedExts[fileExt]; !exists {
				targets <- pathName
			}
		}
		return nil
	}
	err := filepath.Walk(dirName, visit)
	HandleError(err, false)
	close(targets)
}

func main() {
	startTime := time.Now()
	flags.Parse(&args)

	// check config path
	if args.RulesDir == "" {
		args.RulesDir = DefaultDir
		if _, err := os.Stat(args.RulesDir); os.IsNotExist(err) {
			args.RulesDir, _ = os.Getwd()
		}
	}
	if args.Verbose {
		fmt.Printf("DEBUG: rules directory: '%s'\n", args.RulesDir)
	}

	// update rules if required
	if args.Update {
		UpdateRules()
		os.Exit(0)
	}

	// set language
	if args.Language == "" {
		args.Language = DetermineFormat(args.Positional.Target)
	}
	if args.Verbose {
		fmt.Printf("DEBUG: language: '%s'\n", args.Language)
	}

	// add custom excluded file extensions
	if args.ExcludeCommon {
		for _, commonExt := range commonExts {
			excludedExts[commonExt] = struct{}{}
		}
	}
	if args.ExcludeImgs || args.ExcludeCommon {
		for _, imgExt := range imageExts {
			excludedExts[imgExt] = struct{}{}
		}
	}
	for _, ext := range args.ExcludedExts {
		if string(ext[0]) != "." {
			ext = "." + ext
		}
		excludedExts[ext] = struct{}{}
	}
	if args.Verbose {
		extList := make([]string, len(excludedExts))
		i := 0
		for ext := range excludedExts {
			extList[i] = ext[1:]
			i++
		}
		fmt.Printf("DEBUG: excluded file extensions: %s\n", strings.Join(extList, ","))
	}

	// load appropriate YARA rules
	ruleFile := args.Language + ".yar"
	rulePath := path.Join(args.RulesDir, ruleFile)
	if _, err := os.Stat(rulePath); os.IsNotExist(err) {
		fmt.Printf("ERROR: %s not found in default locations or in %s\n", ruleFile, args.RulesDir)
		os.Exit(1)
	}
	data, _ := ioutil.ReadFile(rulePath)
	rules, _ := yara.Compile(string(data), nil)
	if args.Verbose {
		fmt.Printf("DEBUG: ruleset loaded: '%s'\n", ruleFile)
	}

	// set YARA scan flags
	if args.Fast {
		scanFlags = yara.ScanFlags(yara.ScanFlagsFastMode)
	} else {
		scanFlags = yara.ScanFlags(0)
	}

	// check if requested threads count is not greater than YARA's MAX_THREADS
	if args.Workers > YaraMaxThreads {
		fmt.Printf("WARNING: workers count too high, using %d instead of %d\n", YaraMaxThreads, args.Workers)
		args.Workers = YaraMaxThreads
	}

	// scan target
	if f, err := os.Stat(args.Positional.Target); os.IsNotExist(err) {
		fmt.Println("ERROR: invalid target")
		os.Exit(1)
	} else {
		if args.Verbose {
			fmt.Printf("DEBUG: scan workers: %d\n", args.Workers)
			fmt.Printf("DEBUG: target: '%s'\n", args.Positional.Target)
		}
		if f.IsDir() { // parallelized folder scan
			// create communication channels
			targets := make(chan string)
			results := make(chan map[string][]string)

			// rate limit
			var tickerRate time.Duration
			if args.RateLimit == 0 {
				tickerRate = time.Nanosecond
			} else {
				tickerRate = time.Second / time.Duration(args.RateLimit)
			}
			ticker := time.Tick(tickerRate)
			if args.Verbose {
				fmt.Println("DEBUG: delay between fs ops:", tickerRate.String())
			}

			// start consumers and producer workers
			for w := 1; w <= args.Workers; w++ {
				go ProcessFiles(rules, targets, results, ticker)
			}
			go ScanDir(args.Positional.Target, targets, ticker)

			// read results
			matchCount := make(map[string]int)
			var keepListing bool
			var countedDangerousMatch bool
			for result := range results {
				for target, matchedSigs := range result {
					keepListing = true
					matchCount[target] = 0
					countedDangerousMatch = false
					for _, sig := range matchedSigs {
						matchCount[target] += DangerousMatchWeight
						if !countedDangerousMatch {
							if _, exists := dangerousMatches[sig]; exists {
								matchCount[target]++
							}
							countedDangerousMatch = true
						}
						if keepListing {
							fmt.Printf("%s %s\n", target, sig)
							if !args.ShowAll {
								keepListing = false
							}
						}
					}
				}
			}
			fmt.Println("\n===================================================")
			fmt.Println(" You should take a look at the files listed below:")
			fmt.Println("===================================================\n")
			for target, count := range matchCount {
				if count >= DangerousMinScore {
					fmt.Println(target)
				}
			}
		} else { // single file mode
			scannedFilesCount++
			matches, err := rules.ScanFile(args.Positional.Target, scanFlags, ScanMaxDuration)
			HandleError(err, true)
			for _, match := range matches {
				fmt.Printf("%s %s\n", args.Positional.Target, match.Rule)
				if !args.ShowAll {
					break
				}
			}
		}
		if args.Verbose {
			endTime := time.Now()
			fmt.Printf("DEBUG: scanned %d files in %s\n", scannedFilesCount, endTime.Sub(startTime).String())
		}
	}
}
